"""
Enhanced INI Parser for Varken with Multi-Database Support
Supports configuration for multiple database backends
"""

from configparser import ConfigParser
from typing import List
from dataclasses import dataclass
from varken.dbmanager_v2 import DatabaseConfig


@dataclass
class InfluxServer:
    """Legacy InfluxDB server configuration"""
    url: str
    port: int
    username: str
    password: str
    ssl: bool
    verify_ssl: bool


class EnhancedINIParser:
    """
    Enhanced configuration parser supporting multiple database backends
    """
    
    def __init__(self, config_path: str):
        self.config = ConfigParser()
        self.config.read(config_path)
        
        # Parse all database configurations
        self.database_configs: List[DatabaseConfig] = []
        self._parse_databases()
        
        # Legacy support - create influx_server if InfluxDB v1 is configured
        self.influx_server = self._create_legacy_influx_server()
        
        # Parse other sections (sonarr, radarr, etc.) - keep existing logic
        self._parse_services()
    
    def _parse_databases(self):
        """Parse all database backend configurations"""
        
        # Parse InfluxDB v1 (check both uppercase and lowercase for backward compatibility)
        if self.config.has_section('INFLUXDB') or self.config.has_section('influxdb'):
            influx_config = self._parse_influxdb_v1()
            if influx_config:
                self.database_configs.append(influx_config)
        
        # Parse InfluxDB v2
        if self.config.has_section('INFLUXDB2'):
            influx2_config = self._parse_influxdb_v2()
            if influx2_config:
                self.database_configs.append(influx2_config)
        
        # Parse InfluxDB v3
        if self.config.has_section('INFLUXDB3'):
            influx3_config = self._parse_influxdb_v3()
            if influx3_config:
                self.database_configs.append(influx3_config)
        
        # Parse TimescaleDB
        if self.config.has_section('TIMESCALEDB'):
            timescale_config = self._parse_timescaledb()
            if timescale_config:
                self.database_configs.append(timescale_config)
        
        # Parse QuestDB
        if self.config.has_section('QUESTDB'):
            questdb_config = self._parse_questdb()
            if questdb_config:
                self.database_configs.append(questdb_config)
    
    def _parse_influxdb_v1(self) -> DatabaseConfig:
        """Parse InfluxDB v1 configuration (supports both old and new format)"""
        # Check for uppercase first (new format), then lowercase (old format)
        section = 'INFLUXDB' if self.config.has_section('INFLUXDB') else 'influxdb'
        
        # Try to get hostname, fallback to 'url' for old configs
        hostname = self.config.get(section, 'hostname', fallback=None)
        if not hostname:
            hostname = self.config.get(section, 'url', fallback='localhost')
        
        # Try to get user, fallback to 'username' for old configs  
        username = self.config.get(section, 'user', fallback=None)
        if not username:
            username = self.config.get(section, 'username', fallback='')
        
        return DatabaseConfig(
            db_type='influxdb1',
            url=hostname,
            port=self.config.getint(section, 'port', fallback=8086),
            username=username,
            password=self.config.get(section, 'password', fallback=''),
            database=self.config.get(section, 'db', fallback='varken'),
            ssl=self.config.getboolean(section, 'ssl', fallback=False),
            verify_ssl=self.config.getboolean(section, 'verify_ssl', fallback=True),
            enabled=self.config.getboolean(section, 'enabled', fallback=True)
        )
    
    def _parse_influxdb_v2(self) -> DatabaseConfig:
        """Parse InfluxDB v2 configuration"""
        section = 'INFLUXDB2'
        return DatabaseConfig(
            db_type='influxdb2',
            url=self.config.get(section, 'hostname', fallback='localhost'),
            port=self.config.getint(section, 'port', fallback=8086),
            token=self.config.get(section, 'token', fallback=''),
            org=self.config.get(section, 'org', fallback=''),
            bucket=self.config.get(section, 'bucket', fallback='varken'),
            ssl=self.config.getboolean(section, 'ssl', fallback=False),
            verify_ssl=self.config.getboolean(section, 'verify_ssl', fallback=True),
            enabled=self.config.getboolean(section, 'enabled', fallback=True)
        )
    
    def _parse_influxdb_v3(self) -> DatabaseConfig:
        """Parse InfluxDB v3 configuration"""
        section = 'INFLUXDB3'
        return DatabaseConfig(
            db_type='influxdb3',
            url=self.config.get(section, 'hostname', fallback='localhost'),
            port=self.config.getint(section, 'port', fallback=443),
            token=self.config.get(section, 'token', fallback=''),
            org=self.config.get(section, 'org', fallback=''),
            bucket=self.config.get(section, 'bucket', fallback='varken'),
            database=self.config.get(section, 'database', fallback='varken'),
            ssl=self.config.getboolean(section, 'ssl', fallback=True),
            verify_ssl=self.config.getboolean(section, 'verify_ssl', fallback=True),
            enabled=self.config.getboolean(section, 'enabled', fallback=True)
        )
    
    def _parse_timescaledb(self) -> DatabaseConfig:
        """Parse TimescaleDB configuration"""
        section = 'TIMESCALEDB'
        return DatabaseConfig(
            db_type='timescale',
            url=self.config.get(section, 'hostname', fallback='localhost'),
            port=self.config.getint(section, 'port', fallback=5432),
            username=self.config.get(section, 'user', fallback='postgres'),
            password=self.config.get(section, 'password', fallback=''),
            database=self.config.get(section, 'database', fallback='varken'),
            ssl=self.config.getboolean(section, 'ssl', fallback=False),
            enabled=self.config.getboolean(section, 'enabled', fallback=True)
        )
    
    def _parse_questdb(self) -> DatabaseConfig:
        """Parse QuestDB configuration"""
        section = 'QUESTDB'
        return DatabaseConfig(
            db_type='questdb',
            url=self.config.get(section, 'hostname', fallback='localhost'),
            port=self.config.getint(section, 'port', fallback=9000),
            username=self.config.get(section, 'user', fallback=''),
            password=self.config.get(section, 'password', fallback=''),
            ssl=self.config.getboolean(section, 'ssl', fallback=False),
            enabled=self.config.getboolean(section, 'enabled', fallback=True)
        )
    
    def _create_legacy_influx_server(self):
        """Create legacy InfluxServer object for backward compatibility"""
        # Find first InfluxDB v1 config
        influx_v1 = next((c for c in self.database_configs if c.db_type == 'influxdb1'), None)
        if influx_v1:
            return InfluxServer(
                url=influx_v1.url,
                port=influx_v1.port,
                username=influx_v1.username,
                password=influx_v1.password,
                ssl=influx_v1.ssl,
                verify_ssl=influx_v1.verify_ssl
            )
        return None
    
    def _parse_services(self):
        """Parse service configurations (sonarr, radarr, etc.)"""
        # TODO: Implement existing service parsing logic
        # This would parse SONARR, RADARR, TAUTULLI, etc. sections
        pass
    
    def get_database_configs(self) -> List[DatabaseConfig]:
        """Get all configured database backends"""
        return self.database_configs
    
    def get_enabled_databases(self) -> List[DatabaseConfig]:
        """Get only enabled database backends"""
        return [c for c in self.database_configs if c.enabled]
